create table merlin.activity_directive (
  id integer generated by default as identity,
  plan_id integer not null,

  name text,
  source_scheduling_goal_id integer,
  source_scheduling_goal_invocation_id integer default null,
  created_at timestamptz not null default now(),
  created_by text,
  last_modified_at timestamptz not null default now(),
  last_modified_by text,
  start_offset interval not null,
  type text not null,
  arguments merlin.argument_set not null,
  last_modified_arguments_at timestamptz not null default now(),
  metadata merlin.activity_directive_metadata_set default '{}'::jsonb,

  anchor_id integer default null,
  anchored_to_start boolean default true not null,
  constraint activity_directive_natural_key
    primary key (id, plan_id),
  constraint activity_directive_owned_by_plan
    foreign key (plan_id)
    references merlin.plan
    on update cascade
    on delete cascade,
  -- An activity cannot anchor to an activity in another plan
  constraint anchor_in_plan
    foreign key (anchor_id, plan_id)
      references merlin.activity_directive
      on update cascade
      on delete restrict,
  constraint activity_directive_last_modified_by_exists
    foreign key (last_modified_by)
    references permissions.users
    on update cascade
    on delete set null,
  constraint activity_directive_created_by_exists
    foreign key (created_by)
    references permissions.users
    on update cascade
    on delete set null,
  constraint activity_directive_source_goal_id_exists
    foreign key (source_scheduling_goal_id)
    references scheduler.scheduling_goal_metadata
    on update cascade
    on delete set null,
  constraint activity_directive_source_goal_invocation_id_exists
    foreign key (source_scheduling_goal_invocation_id)
    references scheduler.scheduling_specification_goals
    on update cascade
    on delete set null
);

create index activity_directive_plan_id_index on merlin.activity_directive (plan_id);


comment on table merlin.activity_directive is e''
  'A single activity_directive within a plan.';

comment on column merlin.activity_directive.id is e''
  'The synthetic identifier for this activity_directive.\n'
  'Unique within a given plan.';
comment on column merlin.activity_directive.plan_id is e''
  'The plan within which this activity_directive is located.';
comment on column merlin.activity_directive.name is e''
  'The name of this activity_directive.';
comment on column merlin.activity_directive.source_scheduling_goal_id is e''
  'The scheduling goal that this activity_directive was generated by.';
comment on column merlin.activity_directive.source_scheduling_goal_invocation_id is e''
  'The scheduling goal invocation that this activity_directive was generated by.';
comment on column merlin.activity_directive.created_at is e''
  'The time at which this activity_directive was created.';
comment on column merlin.activity_directive.created_by is e''
  'The user who originally created this activity_directive.';
comment on column merlin.activity_directive.last_modified_at is e''
  'The time at which this activity_directive was last modified.';
comment on column merlin.activity_directive.last_modified_by is e''
  'The user who last modified this activity_directive.';
comment on column merlin.activity_directive.last_modified_arguments_at is e''
  'The time at which this activity_directive.arguments was last modified.';
comment on column merlin.activity_directive.start_offset is e''
  'The non-negative time offset from the start of the plan at which this activity_directive is scheduled.';
comment on column merlin.activity_directive.type is e''
  'The type of the activity_directive, as defined in the mission model associated with the plan.';
comment on column merlin.activity_directive.arguments is e''
  'The set of arguments to this activity_directive, corresponding to the parameters of the associated activity type.';
comment on column merlin.activity_directive.metadata is e''
  'The metadata associated with this activity_directive.';
comment on column merlin.activity_directive.anchor_id is e''
  'The id of the activity_directive this activity_directive is anchored to. '
  'The value null indicates that this activity_directive is anchored to the plan.';
comment on column merlin.activity_directive.anchored_to_start is e''
  'If true, this activity_directive is anchored to the start time of its anchor. '
  'If false, this activity_directive is anchored to the end time of its anchor.';

-- Insert Triggers

create function merlin.increment_plan_revision_on_directive_insert()
returns trigger
security definer
language plpgsql as $$begin
  update merlin.plan
  set revision = revision + 1
  where id = new.plan_id;

  return new;
end$$;

create trigger increment_plan_revision_on_directive_insert_trigger
after insert on merlin.activity_directive
for each row
execute function merlin.increment_plan_revision_on_directive_insert();

-- Update Triggers

create function merlin.increment_plan_revision_on_directive_update()
returns trigger
security definer
language plpgsql as $$begin
  update merlin.plan
  set revision = revision + 1
  where id = new.plan_id
    or id = old.plan_id;

  return new;
end$$;

create trigger increment_plan_revision_on_directive_update_trigger
after update on merlin.activity_directive
for each row
execute function merlin.increment_plan_revision_on_directive_update();

create function merlin.increment_plan_revision_on_directive_delete()
returns trigger
security invoker
language plpgsql as $$begin
  update merlin.plan
  set revision = revision + 1
  where id = old.plan_id;

  return old;
end$$;

create trigger increment_plan_revision_on_directive_delete_trigger
after delete on merlin.activity_directive
for each row
execute function merlin.increment_plan_revision_on_directive_delete();

create function merlin.generate_activity_directive_name()
returns trigger
security invoker
language plpgsql as $$begin
  call merlin.plan_locked_exception(new.plan_id);
  if new.name is null then
    new.name = new.type || ' ' || new.id;
  end if;
  return new;
end$$;

comment on function merlin.generate_activity_directive_name() is e''
  'Generates a name for an activity_directive as the activity type + activity id.';

create trigger generate_name_trigger
before insert on merlin.activity_directive
for each row execute function merlin.generate_activity_directive_name();

comment on trigger generate_name_trigger on merlin.activity_directive is e''
  'Generates a name for an activity_directive as the activity type + activity id.';

create function merlin.set_last_modified_at()
returns trigger
security invoker
language plpgsql as $$begin
  new.last_modified_at = now();
  return new;
end$$;

create trigger set_timestamp
  before update on merlin.activity_directive
  for each row
execute function merlin.set_last_modified_at();

comment on trigger set_timestamp on merlin.activity_directive is e''
  'Sets the last_modified_at field of an activity_directive to the current time.';

create function merlin.activity_directive_set_arguments_updated_at()
  returns trigger
  security definer
  language plpgsql as
$$ begin
  call merlin.plan_locked_exception(new.plan_id);
  new.last_modified_arguments_at = now();

  -- request new validation
  update merlin.activity_directive_validations
    set last_modified_arguments_at = new.last_modified_arguments_at,
        status = 'pending'
    where (directive_id, plan_id) = (new.id, new.plan_id);

  return new;
end $$;

comment on function merlin.activity_directive_set_arguments_updated_at() is e''
  'Sets the last_modified_arguments_at field of an activity_directive to the current time.';

create trigger set_arguments_timestamp
  before update of arguments on merlin.activity_directive
  for each row
execute function merlin.activity_directive_set_arguments_updated_at();

comment on trigger set_arguments_timestamp on merlin.activity_directive is e''
  'Sets the last_modified_arguments_at field of an activity_directive to the current time.';

create function merlin.activity_directive_validation_entry()
  returns trigger
  security definer
  language plpgsql as
$$ begin
  insert into merlin.activity_directive_validations
    (directive_id, plan_id, last_modified_arguments_at)
    values (new.id, new.plan_id, new.last_modified_arguments_at);
  return new;
end $$;

create trigger validation_entry_on_insert
  after insert on merlin.activity_directive
  for each row
execute function merlin.activity_directive_validation_entry();

create function merlin.check_activity_directive_metadata()
returns trigger
security definer
language plpgsql as $$
  declare
    _key text;
    _value jsonb;
    _schema jsonb;
    _type text;
    _subValue jsonb;
  begin
  call merlin.plan_locked_exception(new.plan_id);
  for _key, _value in
    select * from jsonb_each(new.metadata::jsonb)
  loop
    select schema into _schema from merlin.activity_directive_metadata_schema where key = _key;
    _type := _schema->>'type';
    if _type = 'string' then
      if jsonb_typeof(_value) != 'string' then
        raise exception 'invalid metadata value for key %. Expected: string, Received: %', _key, _value;
      end if;
    elsif _type = 'long_string' then
      if jsonb_typeof(_value) != 'string' then
        raise exception 'invalid metadata value for key %. Expected: string, Received: %', _key, _value;
      end if;
    elsif _type = 'boolean' then
      if jsonb_typeof(_value) != 'boolean' then
        raise exception 'invalid metadata value for key %. Expected: boolean, Received: %', _key, _value;
      end if;
    elsif _type = 'number' then
      if jsonb_typeof(_value) != 'number' then
        raise exception 'invalid metadata value for key %. Expected: number, Received: %', _key, _value;
      end if;
    elsif _type = 'enum' then
      if (_value not in (select * from jsonb_array_elements(_schema->'enumerates'))) then
        raise exception 'invalid metadata value for key %. Expected: %, Received: %', _key, _schema->>'enumerates', _value;
      end if;
    elsif _type = 'enum_multiselect' then
      if jsonb_typeof(_value) != 'array' then
        raise exception 'invalid metadata value for key %. Expected an array of enumerates: %, Received: %', _key, _schema->>'enumerates', _value;
      end if;
      for _subValue in select * from jsonb_array_elements(_value)
        loop
          if (_subValue not in (select * from jsonb_array_elements(_schema->'enumerates'))) then
            raise exception 'invalid metadata value for key %. Expected one of the valid enumerates: %, Received: %', _key, _schema->>'enumerates', _value;
          end if;
        end loop;
    end if;
  end loop;
  return new;
end$$;

create trigger check_activity_directive_metadata_trigger
before insert or update on merlin.activity_directive
for each row
execute function merlin.check_activity_directive_metadata();

create function merlin.check_locked_on_delete()
  returns trigger
  security definer
  language plpgsql as $$
  begin
    call merlin.plan_locked_exception(old.plan_id);
    return old;
  end $$;

create trigger check_locked_on_delete_trigger
before delete on merlin.activity_directive
for each row
execute procedure merlin.check_locked_on_delete();
