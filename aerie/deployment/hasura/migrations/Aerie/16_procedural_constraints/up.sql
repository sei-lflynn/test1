/************
  Scheduling
 ************/

-- Allow Multiple Invocations and Arguments on the Model Spec
alter table scheduler.scheduling_model_specification_goals
add column goal_invocation_id integer generated by default as identity,
add column arguments jsonb not null default '{}'::jsonb,
drop constraint scheduling_model_specification_goals_pkey,
add primary key (goal_invocation_id);

comment on column scheduler.scheduling_model_specification_goals.model_id is e''
'The model which this specification is for.';
comment on column scheduler.scheduling_model_specification_goals.goal_invocation_id is e''
'The id of a specific goal invocation in the specification. Primary key.';
comment on column scheduler.scheduling_model_specification_goals.goal_id is e''
'The id of a specific scheduling goal in the specification.';
comment on column scheduler.scheduling_model_specification_goals.arguments is e''
'The arguments that will be passed to this goal when invoked.'
'Follows scheduler.scheduling_goal_definition.parameter_schema.'
'Only valid for procedural goals.';

-- Update Plan Spec Creation Function
create or replace function scheduler.create_scheduling_spec_for_new_plan()
returns trigger
security definer
language plpgsql as $$
declare
  spec_id integer;
begin
  -- Create a new scheduling specification
  insert into scheduler.scheduling_specification (revision, plan_id, plan_revision, horizon_start, horizon_end,
                                                  simulation_arguments, analysis_only)
  values (0, new.id, new.revision, new.start_time, new.start_time+new.duration, '{}', false)
  returning id into spec_id;

  -- Populate the scheduling specification
  insert into scheduler.scheduling_specification_goals (specification_id, goal_id, goal_revision, priority, arguments)
  select spec_id, msg.goal_id, msg.goal_revision, msg.priority, msg.arguments
  from scheduler.scheduling_model_specification_goals msg
  where msg.model_id = new.model_id
  order by msg.priority;

  insert into scheduler.scheduling_specification_conditions (specification_id, condition_id, condition_revision)
  select spec_id, msc.condition_id, msc.condition_revision
  from scheduler.scheduling_model_specification_conditions msc
  where msc.model_id = new.model_id;

  return new;
end
$$;

-- Fix Update Priority Functions
create or replace function scheduler.update_scheduling_model_specification_goal_func()
  returns trigger
  language plpgsql as $$
  declare
    max_priority integer;
begin
  select count(goal_invocation_id) - 1
  from scheduler.scheduling_model_specification_goals smg
  where smg.model_id = new.model_id
  into max_priority;

  if new.priority > max_priority then
    raise numeric_value_out_of_range using
      message = ('Updated priority '|| new.priority ||' for model '|| new.model_id ||' is out of bounds.'),
      hint = ('There are only '|| (max_priority + 1) ||' goals on the specification');
  end if;

  if new.priority > old.priority then
    update scheduler.scheduling_model_specification_goals
    set priority = priority - 1
    where model_id = new.model_id
      and priority between old.priority + 1 and new.priority
      and goal_invocation_id != new.goal_invocation_id;
  else
    update scheduler.scheduling_model_specification_goals
    set priority = priority + 1
    where model_id = new.model_id
      and priority between new.priority and old.priority - 1
      and goal_invocation_id != new.goal_invocation_id;
  end if;
  return new;
end;
$$;

create or replace function scheduler.update_scheduling_specification_goal_func()
  returns trigger
  language plpgsql as $$
  declare
    max_priority integer;
begin
  select count(goal_invocation_id) - 1
  from scheduler.scheduling_specification_goals ssg
  where ssg.specification_id = new.specification_id
  into max_priority;

  if new.priority > max_priority then
    raise numeric_value_out_of_range using
      message = ('Updated priority '|| new.priority ||' for specification '|| new.specification_id ||' is out of bounds.'),
      hint = ('There are only '|| (max_priority + 1) ||' goals on the specification');
  end if;

  if new.priority > old.priority then
    update scheduler.scheduling_specification_goals
    set priority = priority - 1
    where specification_id = new.specification_id
      and priority between old.priority + 1 and new.priority
      and goal_invocation_id != new.goal_invocation_id;
  else
    update scheduler.scheduling_specification_goals
    set priority = priority + 1
    where specification_id = new.specification_id
      and priority between new.priority and old.priority - 1
      and goal_invocation_id != new.goal_invocation_id;
  end if;
  return new;
end;
$$;

-- Fix existing specifications that have escaped boundaries

-- Temporary disable the on-update trigger.
-- This statement is going to impact every row in the table and set it to a collision-free value,
-- so we do not need the trigger to go in and change any priorities
-- (and in fact, letting the trigger run will cause issues, due to it trying to alter the priority of rows whose priorities are already being altered)
drop trigger update_scheduling_model_specification_goal on scheduler.scheduling_model_specification_goals;
with priorities as (
  select
    goal_invocation_id,
    row_number() over (partition by model_id order by priority) as new_prio
  from scheduler.scheduling_model_specification_goals smg
)
update scheduler.scheduling_model_specification_goals smg
set priority = p.new_prio - 1 -- -1, as priority starts at 0
from priorities p
where p.goal_invocation_id = smg.goal_invocation_id;
-- Reenable trigger
create trigger update_scheduling_model_specification_goal
  before update on scheduler.scheduling_model_specification_goals
  for each row
  when (OLD.priority is distinct from NEW.priority and pg_trigger_depth() < 1)
execute function scheduler.update_scheduling_model_specification_goal_func();

-- Temporarily disable update trigger
drop trigger update_scheduling_specification_goal on scheduler.scheduling_specification_goals;
with priorities as (
  select
    goal_invocation_id,
    row_number() over (partition by specification_id order by priority) as new_prio
  from scheduler.scheduling_specification_goals ssg
)
update scheduler.scheduling_specification_goals ssg
set priority = p.new_prio - 1 -- -1, as priority starts at 0
from priorities p
where p.goal_invocation_id = ssg.goal_invocation_id;
-- Reenable trigger
create trigger update_scheduling_specification_goal
  before update on scheduler.scheduling_specification_goals
  for each row
  when (old.priority IS DISTINCT FROM new.priority AND pg_trigger_depth() < 1)
execute function scheduler.update_scheduling_specification_goal_func();

/*************
  Constraints
 *************/
-- Create Constraint type
create type merlin.constraint_type as enum ('EDSL', 'JAR');

----------------
-- Definition --
----------------
-- Update Constraint Definition to use new type
alter table merlin.constraint_definition
  add column type merlin.constraint_type not null default 'EDSL',
  alter column definition drop not null,
  add column uploaded_jar_id integer,
  add column parameter_schema jsonb,
  add constraint constraint_procedure_has_uploaded_jar
    foreign key (uploaded_jar_id)
      references merlin.uploaded_file
      on update cascade
      on delete restrict,
  add constraint check_constraint_definition_type_consistency
    check (
      (type = 'EDSL' and definition is not null and uploaded_jar_id is null)
      or
      (type = 'JAR' and uploaded_jar_id is not null and definition is null)
    );

comment on column merlin.constraint_definition.type is e''
  'The type of this definition, "EDSL" or "JAR".';
comment on column merlin.constraint_definition.definition is e''
  'An executable expression in the Merlin constraint language.'
  'Should be non-null when type is EDSL';
comment on column merlin.constraint_definition.uploaded_jar_id is e''
  'The foreign key to the uploaded_file entry containing the procedure jar'
  'Should be non-null when type is JAR';
comment on column merlin.constraint_definition.parameter_schema is e''
  'The schema for parameters that can be passed to constraint instances using this definition.'
  'Similar schema to parameter_set''s in Merlin.';

---------------
-- Plan Spec --
---------------
alter table merlin.constraint_specification
  add column invocation_id integer generated by default as identity,
  add column arguments jsonb not null default '{}'::jsonb,
  add column priority integer,
  drop constraint constraint_specification_pkey,
  add primary key (invocation_id);

comment on table merlin.constraint_specification is e''
  'The set of constraints to be checked for a given plan.';
comment on column merlin.constraint_specification.invocation_id is e''
  'The id of a specific constraint invocation in the specification. Primary key.';
comment on column merlin.constraint_specification.plan_id is e''
  'The plan which this specification is for.';
comment on column merlin.constraint_specification.constraint_id is e''
  'The id of a specific constraint in the specification.';
comment on column merlin.constraint_specification.constraint_revision is e''
  'The version of the constraint definition to use. Leave NULL to use the latest version.';
comment on column merlin.constraint_specification.priority is e''
  'The relative priority of a constraint in relation to other '
  'constraints within the same specification.';
comment on column merlin.constraint_specification.enabled is e''
  'Whether to run a given constraint. Defaults to TRUE.';
comment on column merlin.constraint_specification.arguments is e''
  'The arguments that will be passed to this constraint when invoked.'
  'Follows merlin.constraint_definition.parameter_schema.'
  'Only valid for procedural constraint.';

-- Initialize priority
with priorities as (
  select
    invocation_id,
    row_number() over (partition by plan_id) as new_prio
  from merlin.constraint_specification
  order by plan_id, invocation_id
)
update merlin.constraint_specification cs
set priority = p.new_prio - 1 -- -1, as priority starts at 0
from priorities p
where p.invocation_id = cs.invocation_id;

-- Finish assigning table definition
alter table merlin.constraint_specification
  alter column priority set not null,
  add constraint constraint_specification_unique_priorities
    unique (plan_id, priority) deferrable initially deferred,
  add constraint non_negative_constraint_priority
    check (priority >= 0);

-- Add priority triggers
create function merlin.insert_constraint_spec_func()
  returns trigger
  language plpgsql as $$
  declare
    next_priority integer;
begin
  select coalesce(
    (select priority
     from merlin.constraint_specification cs
     where cs.plan_id = new.plan_id
     order by priority desc
     limit 1), -1) + 1
  into next_priority;

  if new.priority > next_priority then
    raise numeric_value_out_of_range using
      message = ('Inserted priority '||new.priority||' for plan '||new.plan_id||'''s constraint specification is not consecutive'),
      hint = ('The next available priority is '||next_priority||'.');
  end if;

  if new.priority is null then
    new.priority = next_priority;
  end if;

  update merlin.constraint_specification
  set priority = priority + 1
  where plan_id = new.plan_id
    and priority >= new.priority;
  return new;
end
$$;

comment on function merlin.insert_constraint_spec_func() is e''
  'Checks that the inserted priority is consecutive, and reorders (increments) higher or equal priorities to make room.';

create trigger insert_constraint_spec
  before insert on merlin.constraint_specification
  for each row
execute function merlin.insert_constraint_spec_func();

create function merlin.update_constraint_spec_func()
  returns trigger
  language plpgsql as $$
  declare
    max_priority integer;
begin
  select count(invocation_id) - 1
  from merlin.constraint_specification cs
  where cs.plan_id = new.plan_id
  into max_priority;

  if new.priority > max_priority then
    raise numeric_value_out_of_range using
      message = ('Updated priority '||new.priority||' for plan '||new.plan_id||'''s constraint specification is out of bounds.'),
      hint = ('Plan '|| new.plan_id || ' only has ' || (max_priority+1) || ' constraints on its specification.');
  end if;

  if new.priority > old.priority then
    update merlin.constraint_specification
    set priority = priority - 1
    where plan_id = new.plan_id
      and priority between old.priority + 1 and new.priority
      and invocation_id != new.invocation_id;
  else
    update merlin.constraint_specification
    set priority = priority + 1
    where plan_id = new.plan_id
      and priority between new.priority and old.priority - 1
      and invocation_id != new.invocation_id;
  end if;
  return new;
end;
$$;

comment on function merlin.update_constraint_spec_func is e''
  'Checks that the updated priority is consecutive, and reorders priorities to make room.';

create trigger update_constraint_spec
  before update on merlin.constraint_specification
  for each row
  when (OLD.priority is distinct from NEW.priority and pg_trigger_depth() < 1)
execute function merlin.update_constraint_spec_func();

create function merlin.delete_constraint_spec_func()
  returns trigger
  language plpgsql as $$
  declare
    r merlin.constraint_specification;
begin
  -- Perform updates in reverse-priority order to ensure that there are no gaps
  for r in select * from removed_rows order by priority desc loop
    update merlin.constraint_specification
    set priority = priority - 1
    where plan_id = r.plan_id
      and priority > r.priority;
  end loop;
  return null;
end;
$$;

comment on function merlin.delete_constraint_spec_func() is e''
  'Reorders (decrements) priorities to fill the gap from deleted priority.';

create trigger delete_constraint_spec
  after delete on merlin.constraint_specification
  referencing old table as removed_rows
  for each statement
execute function merlin.delete_constraint_spec_func();

----------------
-- Model Spec --
----------------
alter table merlin.constraint_model_specification
  add column invocation_id integer generated by default as identity,
  add column arguments jsonb not null default '{}'::jsonb,
  add column priority integer,
  drop constraint constraint_model_spec_pkey,
  add constraint constraint_model_spec_pkey primary key (invocation_id);

comment on column merlin.constraint_model_specification.invocation_id is e''
  'The id of a specific constraint invocation in the specification. Primary key.';
comment on column merlin.constraint_model_specification.model_id is e''
  'The model which this specification is for.';
comment on column merlin.constraint_model_specification.constraint_id is e''
  'The id of a specific constraint in the specification.';
comment on column merlin.constraint_model_specification.priority is e''
  'The relative priority of a constraint in relation to other '
  'constraints within the same specification.';
comment on column merlin.constraint_model_specification.arguments is e''
  'The arguments that will be passed to this constraint when invoked.'
  'Follows merlin.constraint_definition.parameter_schema.'
  'Only valid for procedural constraint.';

-- Initialize priority
with priorities as (
  select
    invocation_id,
    row_number() over (partition by model_id) as new_prio
  from merlin.constraint_model_specification
  order by model_id, invocation_id
)
update merlin.constraint_model_specification cs
set priority = p.new_prio - 1 -- -1, as priority starts at 0
from priorities p
where p.invocation_id = cs.invocation_id;

-- Finish assigning table definition
alter table merlin.constraint_model_specification
  alter column priority set not null,
  add constraint model_spec_unique_constraint_priority
    unique (model_id, priority) deferrable initially deferred,
  add constraint non_negative_constraint_model_priority
    check (priority >= 0);

-- Trigger functions
create function merlin.insert_constraints_model_specification_func()
  returns trigger
  language plpgsql as $$
  declare
    next_priority integer;
begin
  select coalesce(
    (select priority
     from merlin.constraint_model_specification cms
     where cms.model_id = new.model_id
     order by priority desc
     limit 1), -1) + 1
  into next_priority;

  if new.priority > next_priority then
    raise numeric_value_out_of_range using
      message = ('Updated priority % for model_id % is not consecutive', new.priority, new.model_id),
      hint = ('The next available priority is %.', next_priority);
  end if;

  if new.priority is null then
    new.priority = next_priority;
  end if;

  update merlin.constraint_model_specification
  set priority = priority + 1
  where model_id = new.model_id
    and priority >= new.priority;
  return new;
end;
$$;

comment on function merlin.insert_constraints_model_specification_func() is e''
  'Checks that the inserted priority is consecutive, and reorders (increments) higher or equal priorities to make room.';

create trigger insert_constraints_model_specification
  before insert on merlin.constraint_model_specification
  for each row
execute function merlin.insert_constraints_model_specification_func();

create function merlin.update_constraints_model_specification_func()
  returns trigger
  language plpgsql as $$
  declare
    max_priority integer;
begin
  select count(invocation_id) - 1
  from merlin.constraint_model_specification cms
  where cms.model_id = new.model_id
  into max_priority;

  if new.priority > max_priority then
    raise numeric_value_out_of_range using
      message = ('Updated priority '||new.priority||' for model '||new.model_id||''' is out of bounds.'),
      hint = ('Model '|| new.model_id || ' only has ' || (max_priority+1) || ' constraints on its specification.');
  end if;

  if new.priority > old.priority then
    update merlin.constraint_model_specification
    set priority = priority - 1
    where model_id = new.model_id
      and priority between old.priority + 1 and new.priority
      and invocation_id != new.invocation_id;
  else
    update merlin.constraint_model_specification
    set priority = priority + 1
    where model_id = new.model_id
      and priority between new.priority and old.priority - 1
      and invocation_id != new.invocation_id;
  end if;
  return new;
end;
$$;

comment on function merlin.update_constraints_model_specification_func() is e''
  'Checks that the updated priority is consecutive, and reorders priorities to make room.';

create trigger update_constraints_model_specification
  before update on merlin.constraint_model_specification
  for each row
  when (OLD.priority is distinct from NEW.priority and pg_trigger_depth() < 1)
execute function merlin.update_constraints_model_specification_func();

create function merlin.delete_constraints_model_specification_func()
  returns trigger
  language plpgsql as $$
  declare
    r merlin.constraint_model_specification;
begin
  -- Perform updates in reverse-priority order to ensure that there are no gaps
  for r in select * from removed_rows order by priority desc loop
    update merlin.constraint_model_specification
    set priority = priority - 1
    where model_id = r.model_id
      and priority > r.priority;
  end loop;
  return null;
end;
$$;

comment on function merlin.delete_constraints_model_specification_func() is e''
  'Reorders (decrements) priorities to fill the gap from deleted priority.';

create trigger delete_constraints_model_specification
  after delete on merlin.constraint_model_specification
  referencing old table as removed_rows
  for each statement
execute function merlin.delete_constraints_model_specification_func();

-- Alter plan spec creation function
create or replace function merlin.populate_constraint_spec_new_plan()
returns trigger
language plpgsql as $$
begin
  insert into merlin.constraint_specification (plan_id, constraint_id, constraint_revision, arguments, priority)
  select new.id, cms.constraint_id, cms.constraint_revision, cms.arguments, cms.priority
  from merlin.constraint_model_specification cms
  where cms.model_id = new.model_id
  order by priority;
  return new;
end;
$$;

/*********************
  Constraint Requests
 *********************/
-- Remove the old 'Constraint Run' Cache table
drop table merlin.constraint_run;

-- Create New Tables in Correct order
create table merlin.constraint_request (
  id integer not null generated always as identity
    primary key,
  plan_id integer not null,
  simulation_dataset_id integer not null, -- "not null", as we reject rqs if there aren't up-to-date sim results
                                          -- (or if the provided sim dataset id is invalid)
  force_rerun boolean,

  -- Additional Metadata
  requested_by text,
  requested_at timestamptz not null default now(),

  constraint constraint_request_plan
    foreign key (plan_id)
      references merlin.plan
      on delete cascade,
  constraint constraint_request_simulation_dataset
    foreign key (simulation_dataset_id)
      references merlin.simulation_dataset
      on delete cascade,
  constraint constraint_request_requested_by
    foreign key (requested_by)
      references permissions.users
      on update cascade
      on delete set null
);

comment on table merlin.constraint_request is e''
 'A record of the inputs to an executed constraint request.';
comment on column merlin.constraint_request.id is e''
 'The generated identifier for this request.';
comment on column merlin.constraint_request.plan_id is e''
 'The plan used during this request.';
comment on column merlin.constraint_request.simulation_dataset_id is e''
 'The simulation results used during this request.';
comment on column merlin.constraint_request.force_rerun is e''
 'Whether this request specified the "force" flag.';

create table merlin.constraint_results (
  id integer not null generated always as identity,

  -- inputs
  constraint_id integer not null,
  constraint_revision integer not null,
  simulation_dataset_id integer not null,
  arguments jsonb not null,

  -- outputs
  results jsonb not null default '{}',
  errors jsonb not null default '{}',

  constraint constraint_results_key
    primary key (id),
  constraint constraint_results_to_constraint_definition
    foreign key (constraint_id, constraint_revision)
      references merlin.constraint_definition
      on delete cascade,
  constraint constraint_results_to_simulation_dataset
    foreign key (simulation_dataset_id)
      references merlin.simulation_dataset
      on delete cascade
);

create index constraint_results_simulation_dataset_id_index
  on merlin.constraint_results (simulation_dataset_id);

comment on table merlin.constraint_results is e''
  'The output of running a single constraint. Results are cached to avoid unnecessary execution.';

comment on column merlin.constraint_results.id is e''
  'The generated identifier for this results.';
comment on column merlin.constraint_results.constraint_id is e''
  'The constraint that was checked.';
comment on column merlin.constraint_results.constraint_revision is e''
  'The version of the constraint definition that was checked.';
comment on column merlin.constraint_results.simulation_dataset_id is e''
  'The simulation dataset the constraint was checked against.';
comment on column merlin.constraint_results.arguments is e''
  'The arguments provided to the constraint when checked.';
comment on column merlin.constraint_results.results is e''
  'Results that were computed during the constraint check.';
comment on column merlin.constraint_results.errors is e''
  'Errors that occurred while checking the constraint.';

create table merlin.constraint_run(
  request_id integer not null,
  constraint_invocation_id integer not null,
  constraint_results_id integer not null,
  priority integer not null,

  constraint constraint_run_pkey
    primary key (request_id, constraint_invocation_id, constraint_results_id),
  constraint constraint_run_request foreign key (request_id)
    references merlin.constraint_request
    on delete cascade,
  constraint constraint_run_invocation foreign key (constraint_invocation_id)
    references merlin.constraint_specification
    on delete cascade,
  constraint constraint_run_results foreign key (constraint_results_id)
    references merlin.constraint_results
    on delete restrict
);

comment on table merlin.constraint_run is e''
  'A join table connecting each constraint run during a request to its result.';

comment on column merlin.constraint_run.request_id is e''
  'The constraint request during which this constraint was checked.';
comment on column merlin.constraint_run.constraint_invocation_id is e''
  'The constraint that was checked.';
comment on column merlin.constraint_run.constraint_results_id is e''
  'The output of checking the constraint.';
comment on column merlin.constraint_run.priority is e''
  'The priority the constraint had when checked.';
comment on column merlin.constraint_request.requested_by is e''
 'The user who made the request.';
comment on column merlin.constraint_request.requested_at is e''
 'The time at which the request was made.';

call migrations.mark_migration_applied('16');
