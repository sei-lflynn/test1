update merlin.activity_directive
set source_scheduling_goal_id = null
where not exists(
select from scheduler.scheduling_goal_metadata
       where activity_directive.id = source_scheduling_goal_id);

alter table merlin.activity_directive
  add column source_scheduling_goal_invocation_id integer default null,

  add constraint activity_directive_source_goal_id_exists
    foreign key (source_scheduling_goal_id)
    references scheduler.scheduling_goal_metadata
    on update cascade
    on delete set null,

  add constraint activity_directive_source_goal_invocation_id_exists
    foreign key (source_scheduling_goal_invocation_id)
    references scheduler.scheduling_specification_goals
    on update cascade
    on delete set null;

comment on column merlin.activity_directive.source_scheduling_goal_invocation_id is e''
  'The scheduling goal invocation that this activity_directive was generated by.';

create or replace function hasura.delete_activity_by_pk_reanchor_plan_start(_activity_id int, _plan_id int, hasura_session json)
  returns setof hasura.delete_anchor_return_value
  strict
  volatile
language plpgsql as $$
  declare
    _function_permission permissions.permission;
  begin
    _function_permission := permissions.get_function_permissions('delete_activity_reanchor_plan', hasura_session);
    perform permissions.raise_if_plan_merge_permission('delete_activity_reanchor_plan', _function_permission);
    if not _function_permission = 'NO_CHECK' then
      call permissions.check_general_permissions('delete_activity_reanchor_plan', _function_permission, _plan_id, (hasura_session ->> 'x-hasura-user-id'));
    end if;

    if not exists(select id from merlin.activity_directive where (id, plan_id) = (_activity_id, _plan_id)) then
      raise exception 'Activity Directive % does not exist in Plan %', _activity_id, _plan_id;
    end if;

    return query
      with updated as (
        select merlin.anchor_direct_descendents_to_plan(_activity_id := _activity_id, _plan_id := _plan_id)
      )
      select updated.*, 'updated'
        from updated;

    return query
      with deleted as (
        delete from merlin.activity_directive where (id, plan_id) = (_activity_id, _plan_id) returning *
      )
      select (deleted.id, deleted.plan_id, deleted.name, deleted.source_scheduling_goal_id, deleted.source_scheduling_goal_invocation_id,
              deleted.created_at, deleted.created_by, deleted.last_modified_at, deleted.last_modified_by, deleted.start_offset, deleted.type, deleted.arguments,
              deleted.last_modified_arguments_at, deleted.metadata, deleted.anchor_id, deleted.anchored_to_start)::merlin.activity_directive, 'deleted' from deleted;
  end
$$;

create or replace function hasura.delete_activity_by_pk_reanchor_to_anchor(_activity_id int, _plan_id int, hasura_session json)
  returns setof hasura.delete_anchor_return_value
  strict
  volatile
  language plpgsql as $$
declare
    _function_permission permissions.permission;
begin
    _function_permission := permissions.get_function_permissions('delete_activity_reanchor', hasura_session);
    perform permissions.raise_if_plan_merge_permission('delete_activity_reanchor', _function_permission);
    if not _function_permission = 'NO_CHECK' then
      call permissions.check_general_permissions('delete_activity_reanchor', _function_permission, _plan_id, (hasura_session ->> 'x-hasura-user-id'));
    end if;

    if not exists(select id from merlin.activity_directive where (id, plan_id) = (_activity_id, _plan_id)) then
      raise exception 'Activity Directive % does not exist in Plan %', _activity_id, _plan_id;
    end if;

    return query
      with updated as (
        select merlin.anchor_direct_descendents_to_ancestor(_activity_id := _activity_id, _plan_id := _plan_id)
      )
      select updated.*, 'updated'
        from updated;
    return query
      with deleted as (
        delete from merlin.activity_directive where (id, plan_id) = (_activity_id, _plan_id) returning *
      )
      select (deleted.id, deleted.plan_id, deleted.name, deleted.source_scheduling_goal_id, deleted.source_scheduling_goal_invocation_id,
              deleted.created_at, deleted.created_by, deleted.last_modified_at, deleted.last_modified_by, deleted.start_offset, deleted.type, deleted.arguments,
              deleted.last_modified_arguments_at, deleted.metadata, deleted.anchor_id, deleted.anchored_to_start)::merlin.activity_directive, 'deleted' from deleted;
end
$$;

create or replace function hasura.delete_activity_by_pk_delete_subtree(_activity_id int, _plan_id int, hasura_session json)
  returns setof hasura.delete_anchor_return_value
  strict
  volatile
  language plpgsql as $$
declare
  _function_permission permissions.permission;
begin
  _function_permission := permissions.get_function_permissions('delete_activity_subtree', hasura_session);
  perform permissions.raise_if_plan_merge_permission('delete_activity_subtree', _function_permission);
  if not _function_permission = 'NO_CHECK' then
    call permissions.check_general_permissions('delete_activity_subtree', _function_permission, _plan_id, (hasura_session ->> 'x-hasura-user-id'));
  end if;

  if not exists(select id from merlin.activity_directive where (id, plan_id) = (_activity_id, _plan_id)) then
    raise exception 'Activity Directive % does not exist in Plan %', _activity_id, _plan_id;
  end if;

  return query
    with recursive
      descendents(activity_id, p_id) as (
          select _activity_id, _plan_id
          from merlin.activity_directive ad
          where (ad.id, ad.plan_id) = (_activity_id, _plan_id)
        union
          select ad.id, ad.plan_id
          from merlin.activity_directive ad, descendents d
          where (ad.anchor_id, ad.plan_id) = (d.activity_id, d.p_id)
      ),
      deleted as (
          delete from merlin.activity_directive ad
            using descendents
            where (ad.plan_id, ad.id) = (_plan_id, descendents.activity_id)
            returning *
      )
      select (deleted.id, deleted.plan_id, deleted.name, deleted.source_scheduling_goal_id, deleted.source_scheduling_goal_invocation_id,
              deleted.created_at, deleted.created_by, deleted.last_modified_at, deleted.last_modified_by, deleted.start_offset, deleted.type, deleted.arguments,
              deleted.last_modified_arguments_at, deleted.metadata, deleted.anchor_id, deleted.anchored_to_start)::merlin.activity_directive, 'deleted' from deleted;
end
$$;

call migrations.mark_migration_applied('19');
